<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277"></td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.7 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>3_linestring_example.cpp</h1>The linestring example shows how linestrings can be declared and used and shows some more algorithms. One of the important concepts of the <a class="el" href="namespacegeometry.html">geometry</a> library is that it is totally built upon the standard library, using the standard containers such as std::vector.<p>
A linestring is, as explained elsewhere in this documentation, not much more than a vector of points. Most algorithms run on linestrings, but can also run on any iterator pair. And all algorithms on std::vector can be used on <a class="el" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring</a>.<p>
The sample shows this, shows some algorithms:<ul>
<li><a class="el" href="group__envelope.html#g2970ab50558bce38e941f06741816cdc" title="Calculate envelope of a point.">geometry::envelope</a></li><li><a class="el" href="group__length.html#g7f80f1de67065fd31a00ae5bc012c884" title="Calculate length of a series of points, specified by an iterator pair.">geometry::length</a></li><li><a class="el" href="group__distance.html#g8998816466251f035b5ab6c3f76f2ec0" title="Calculate distance between two points.">geometry::distance</a></li><li><a class="el" href="group__simplify.html#gb643ed3e965480814d2502edd61fa107" title="Simplify an iterator pair.">geometry::simplify</a></li><li>geometry::for_each</li><li><a class="el" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a></li></ul>
<p>
This documentation illustrates the simplify algorithm and the intersection algorithm with some pictures.<p>
The simplify algorithm simplifies a linestring. Simplification means that the less important points are removed from the line and that the points that are most important for the shape of a line are kept. Simplification is done using the well known Douglas Peucker algorithm. The library user can specify the distance or tolerance, which indicates how much the linestring should be simplified.<p>
The image below shows the original and simplified linestring: <div align="center">
<img src="simplify_example.png" alt="simplify_example.png">
</div>
 The red line is the original linestring; the blue line is the simplified line which has one point less. In geographical applications simplification can reduce a linestring to its basic form containing only 10% of its original points.<p>
The intersection algorithm intersects two geometries which each other, delivering a third <a class="el" href="namespacegeometry.html">geometry</a>. In the case of the example a linestring is intersected with a box. Intersection with a box is often called a clip. The image below illustrates the intersection. <div align="center">
<img src="intersection_linestring_example.png" alt="intersection_linestring_example.png">
</div>
 The red line is intersected with the blue box. The intersection result, painted in black, is a multi_linestring containing three linestrings.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Geometry Library</span>
<span class="comment">//</span>
<span class="comment">// Copyright Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands.</span>
<span class="comment">// Copyright Bruno Lalande 2008</span>
<span class="comment">// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="comment">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;deque&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// for reverse, unique</span>

<span class="preprocessor">#include &lt;<a class="code" href="geometry_8hpp.html">geometry/geometry.hpp</a>&gt;</span>


<span class="keyword">class </span>derived_linestring : <span class="keyword">public</span> geometry::linestring&lt;geometry::point_xy&lt;float&gt;, std::deque, std::allocator&gt;
{
        <span class="keyword">public</span> :
                <span class="keyword">typedef</span> <a name="_a0"></a><a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;point_type&gt;</a> box_type;
                <span class="keyword">inline</span> <span class="keywordtype">void</span> rebox() { <a name="a1"></a><a class="code" href="namespacegeometry.html#9395cd8762bb86099847ae240a465379">geometry::envelope</a>(this-&gt;begin(), this-&gt;end(), m_box); }
                <span class="keyword">inline</span> box_type box()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_box; }
        <span class="keyword">private</span> :
                box_type m_box;

};

<span class="keyword">struct </span>own_linestring : <span class="keyword">public</span> std::vector&lt;geometry::point_xy&lt;double&gt; &gt;
{
        <span class="keyword">typedef</span> <a name="_a2"></a><a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> point_type; <span class="comment">// required for, at least, the simplify_linestring algorithm</span>
};



<span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
std::ostream &amp; operator&lt;&lt;(std::ostream &amp;s, const geometry::box&lt;P&gt; &amp;b)
{
        s &lt;&lt; b.min_corner() &lt;&lt; <span class="stringliteral">" - "</span> &lt;&lt; b.max_corner();
        <span class="keywordflow">return</span> s;
}


<span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">inline</span> <span class="keywordtype">void</span> translate_function(P&amp; p)
{
                p.x(p.x() + 100.0);
}


<span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
<span class="keyword">struct </span>scale_functor
{
        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(P&amp; p)
        {
                p.x(p.x() * 1000.0);
                p.y(p.y() * 1000.0);
        }
};



<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
        <span class="comment">// Define a linestring, which is a vector of points, and add some points</span>
        <a name="_a3"></a><a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;geometry::point_xy&lt;double&gt;</a> &gt; ls;
        ls.push_back(<a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a>(1.1, 1.1));

        <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> lp(2.5, 2.1);
        ls.push_back(lp);

        <span class="comment">// Lines can be streamed as Well Known Text (OGC WKT)</span>
        std::cout &lt;&lt; ls &lt;&lt; std::endl;

        <span class="comment">// The bounding box of lines can be calculated and streamd useing the method above</span>
        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;geometry::point_xy&lt;double&gt;</a> &gt; b;
        <a name="a4"></a><a class="code" href="group__envelope.html#g2970ab50558bce38e941f06741816cdc" title="Calculate envelope of a point.">geometry::envelope</a>(ls.begin(), ls.end(), b);
        std::cout &lt;&lt; b &lt;&lt; std::endl;

        <span class="comment">// The length of the line can be calulated</span>
        std::cout &lt;&lt; <span class="stringliteral">"length: "</span> &lt;&lt; <a name="a5"></a><a class="code" href="group__length.html#g7f80f1de67065fd31a00ae5bc012c884" title="Calculate length of a series of points, specified by an iterator pair.">geometry::length</a>(ls.begin(), ls.end()) &lt;&lt; std::endl;

        <span class="comment">// All things from vector can be called, because a linestring is a vector</span>
        std::cout &lt;&lt; <span class="stringliteral">"number of points: "</span> &lt;&lt; ls.size() &lt;&lt; std::endl;

        <span class="comment">// The distance from a point to a linestring can be calculated</span>
        <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> p(1.9, 1.2);
        std::cout &lt;&lt; <span class="stringliteral">"distance of "</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">" to line: "</span> &lt;&lt; <a name="a6"></a><a class="code" href="group__distance.html#g8998816466251f035b5ab6c3f76f2ec0" title="Calculate distance between two points.">geometry::distance</a>(p, ls.begin(), ls.end()) &lt;&lt; std::endl;

        <span class="comment">// A linestring is a vector. However, some algorithms consider "segments",</span>
        <span class="comment">// which are the line pieces between two points of a linestring.</span>
        <span class="comment">// Here we go to the "primary versions"</span>
        <span class="comment">//geometry::distance_result d = geometry::impl::distance::point_to_segment(</span>
        <span class="comment">//      p, geometry::segment&lt;geometry::point_xy&lt;double&gt; &gt;(ls.front(), ls.back()));</span>
        <span class="comment">//std::cout &lt;&lt; sqrt(geometry::square_distance_point_to_segment(p, geometry::segment&lt;geometry::point_xy&lt;double&gt; &gt;(ls.front(), ls.back()))) &lt;&lt; std::endl;</span>

        <span class="comment">// Add some points more, let's do it using a classic array. See documentation for picture</span>
        <span class="keyword">typedef</span> <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;
        <span class="keyword">const</span> <span class="keywordtype">double</span> c[][2] = { {3.1, 3.1}, {4.9, 1.1}, {3.1, 1.9} };
        <span class="keyword">const</span> <span class="keywordtype">int</span> n = <span class="keyword">sizeof</span>(c) / <span class="keyword">sizeof</span>(c[0]);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
        {
                ls.push_back(P(c[i][0], c[i][1]));
        }
        std::cout &lt;&lt; <span class="stringliteral">"original: "</span> &lt;&lt; ls &lt;&lt; std::endl;

        <span class="comment">// Output as iterator-pair on a vector</span>
        {
                std::vector&lt;geometry::point_xy&lt;double&gt; &gt; v;
                std::copy(ls.begin(), ls.end(), std::back_inserter(v));
                std::cout
                        &lt;&lt; <span class="stringliteral">"as vector-it-pair: "</span>
                        &lt;&lt; geometry::make_as_wkt(std::make_pair(v.begin(), v.end()))
                        &lt;&lt; std::endl;

        }


        <span class="comment">// All algorithms from std can be used: a linestring is a vector</span>
        std::reverse(ls.begin(), ls.end());
        std::cout &lt;&lt; <span class="stringliteral">"reversed: "</span> &lt;&lt; ls &lt;&lt; std::endl;
        std::reverse(ls.begin(), ls.end());

        <span class="comment">// The other way, using a vector instead of a linestring, is also possible</span>
        std::vector&lt;P&gt; pv(ls.begin(), ls.end());
        <span class="comment">// However, you can NOT call length then, because length is defined for linestring&lt;P&gt;</span>
        <span class="comment">// All methods are templatized in two ways, so it is still possible to get the length</span>
        <span class="comment">// but with another name. This is like "find" and "find_if"</span>
        std::cout &lt;&lt; <span class="stringliteral">"length: "</span> &lt;&lt; <a class="code" href="group__length.html#g7f80f1de67065fd31a00ae5bc012c884" title="Calculate length of a series of points, specified by an iterator pair.">geometry::length</a>(pv.begin(), pv.end()) &lt;&lt; std::endl;

        <span class="comment">// If there are double points in the line, you can use unique to remove them</span>
        <span class="comment">// So we add the last point, print, make a unique copy and print</span>
        ls.push_back(ls.back());
        std::cout &lt;&lt; <span class="stringliteral">"extra point: "</span> &lt;&lt; ls &lt;&lt; std::endl;

        {
                <a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;P&gt;</a> ls_copy;
                std::unique_copy(ls.begin(), ls.end(), std::back_inserter(ls_copy));
                ls = ls_copy;
                std::cout &lt;&lt; <span class="stringliteral">"uniquecopy: "</span> &lt;&lt; ls &lt;&lt; std::endl;
        }

        <span class="comment">// Lines can be simplified using e.g. Douglas Peucker</span>
        <a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;P&gt;</a> ls_simplified;
        <a name="a7"></a><a class="code" href="group__simplify.html#gb643ed3e965480814d2502edd61fa107" title="Simplify an iterator pair.">geometry::simplify</a>(ls.begin(), ls.end(), std::back_inserter(ls_simplified), 0.5);
        std::cout &lt;&lt; <span class="stringliteral">"simplified: "</span> &lt;&lt; ls_simplified &lt;&lt; std::endl;

        <span class="comment">// Declare and fill a derived linestring</span>
        derived_linestring dl;
        <span class="keywordflow">for</span> (<a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;P&gt;::const_iterator</a> it = ls.begin(); it != ls.end(); it++)
        {
                dl.push_back(<a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;float&gt;</a>(it-&gt;x(), it-&gt;y()));
        }
        <span class="comment">// In this case it has its own box</span>
        dl.rebox();
        std::cout &lt;&lt; dl.box() &lt;&lt; std::endl;

        derived_linestring dls;
        <span class="comment">// Simplify also works for derived classes</span>
        <a class="code" href="group__simplify.html#gb643ed3e965480814d2502edd61fa107" title="Simplify an iterator pair.">geometry::simplify</a>(dl.begin(), dl.end(), std::back_inserter(dls), 0.5);

        own_linestring ol;
        <span class="keywordflow">for</span> (<a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;P&gt;::const_iterator</a> it = ls.begin(); it != ls.end(); it++)
        {
                ol.push_back(<a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a>(it-&gt;x(), it-&gt;y()));
        }
        own_linestring ols;

        <span class="comment">// and for vectors or for own classes...</span>
        <a class="code" href="group__simplify.html#gb643ed3e965480814d2502edd61fa107" title="Simplify an iterator pair.">geometry::simplify</a>(ol.begin(), ol.end(), std::back_inserter(ols), 0.5);


        <span class="comment">// for_each:</span>
        <span class="comment">// 1) Lines can be visited with std::for_each</span>
        <span class="comment">// 2) geometry::for_each_point is also defined for all geometries</span>
        <span class="comment">// 3) geometry::for_each_segment is defined for all geometries to all segments</span>
        <span class="comment">// 4) geometry::loop is defined for geometries to visit segments</span>
        <span class="comment">//    with state apart, and to be able to break out (not shown here)</span>
        {
                <a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;geometry::point_xy&lt;double&gt;</a> &gt; lscopy = ls;
                std::for_each(ls.begin(), ls.end(), translate_function&lt;P&gt;);
                <a name="a8"></a><a class="code" href="group__loop.html#gc1a18ebf4e65b31638831ef90d19a233" title="Calls functor for point.">geometry::for_each_point</a>(ls.begin(), ls.end(), scale_functor&lt;P&gt;());
                std::cout &lt;&lt; ls &lt;&lt; std::endl;
                ls = lscopy;
                std::cout &lt;&lt; ls &lt;&lt; std::endl;
        }

        <span class="comment">// Finally, lines can be clipped using a clipping box. Clipped lines are added to the output iterator</span>
        <span class="comment">// Clipping is possible using vectors, or geometry::linestring types</span>
        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));

        <span class="comment">// Also possible: clip-output to a vector of vectors</span>
        std::vector&lt;std::vector&lt;P&gt; &gt; vector_out;
        <a name="a9"></a><a class="code" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a>(cb, ls.begin(), ls.end(), std::back_inserter(vector_out));

        std::cout &lt;&lt; <span class="stringliteral">"clipped output as vector:"</span> &lt;&lt; std::endl;
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vector_out.size(); i++)
        {
                std::copy(vector_out[i].begin(), vector_out[i].end(),
                                                std::ostream_iterator&lt;P&gt;(std::cout, <span class="stringliteral">" "</span>));
                std::cout &lt;&lt; std::endl;
        }


        <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 14, 2008</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2008 Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands<br>
Copyright © 2008 Bruno Lalande, Paris, France</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
