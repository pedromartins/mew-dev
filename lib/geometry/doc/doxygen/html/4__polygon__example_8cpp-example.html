<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277"></td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.7 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>4_polygon_example.cpp</h1>The polygon example shows some examples of what can be done with polygons in the Geometry Library: the outer ring and the inner rings how to calculate the area of a polygon how to get the centroid, and how to get an often more interesting label point how to correct the polygon such that it is clockwise and closed within: the well-known point in polygon algorithm how to use polygons which use another container, or which use different containers for points and for inner rings how polygons can be intersected, or clipped, using a clipping box<p>
The illustrations below show the usage of the within algorithm and the intersection algorithm.<p>
The within algorithm results in true if a point lies completly within a polygon. If it lies exactly on a border it is not considered as within and if it is inside a hole it is also not within the polygon. This is illustrated below, where only the point in the middle is within the polygon.<p>
<div align="center">
<img src="within_polygon_example.png" alt="within_polygon_example.png">
</div>
<p>
The clipping algorithm, called intersection, is illustrated below:<p>
<div align="center">
<img src="clip_polygon_example.png" alt="clip_polygon_example.png">
</div>
<p>
The yellow polygon, containing a hole, is clipped with the blue rectangle, resulting in a multi_polygon of three polygons, drawn in red. The hole is vanished.<p>
include polygon_example.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Geometry Library</span>
<span class="comment">//</span>
<span class="comment">// Copyright Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands.</span>
<span class="comment">// Copyright Bruno Lalande 2008</span>
<span class="comment">// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="comment">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>

<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;list&gt;</span>
<span class="preprocessor">#include &lt;deque&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// for reverse, unique</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="envelope_8hpp.html">geometry/algorithms/envelope.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="area_8hpp.html">geometry/algorithms/area.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="foreach_8hpp.html">geometry/algorithms/foreach.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="centroid_8hpp.html">geometry/algorithms/centroid.hpp</a>&gt;</span>
<span class="comment">//#include &lt;geometry/labelinfo.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="intersection_8hpp.html">geometry/algorithms/intersection.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;geometry/io/wkt/streamwkt.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="correct_8hpp.html">geometry/util/correct.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="within_8hpp.html">geometry/algorithms/within.hpp</a>&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="simplify_8hpp.html">geometry/algorithms/simplify.hpp</a>&gt;</span>



std::string boolstr(<span class="keywordtype">bool</span> v)
{
        <span class="keywordflow">return</span> v ? <span class="stringliteral">"true"</span> : <span class="stringliteral">"false"</span>;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
        <span class="comment">// Make a shortcut for a point</span>
        <span class="keyword">typedef</span> <a name="_a0"></a><a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;

        <span class="comment">// Define a polygon and fill the outer ring.</span>
        <span class="comment">// In most cases you will read it from a file or database</span>



        <a name="_a1"></a><a class="code" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">geometry::polygon&lt;P&gt;</a> poly;
        {
                <span class="keyword">const</span> <span class="keywordtype">double</span> coor[][2] = {
                        {2.0, 1.3}, {2.4, 1.7}, {2.8, 1.8}, {3.4, 1.2}, {3.7, 1.6},
                        {3.4, 2.0}, {4.1, 3.0}, {5.3, 2.6}, {5.4, 1.2}, {4.9, 0.8}, {2.9, 0.7},
                        {2.0, 1.3} <span class="comment">// closing point is opening point</span>
                        };
                <span class="keyword">const</span> <span class="keywordtype">int</span> n = <span class="keyword">sizeof</span>(coor) / <span class="keyword">sizeof</span>(coor[0]);
                poly.<a name="a2"></a><a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().reserve(n);
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
                {
                        poly.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(coor[i][0], coor[i][1]));
                }
        }

        <span class="comment">// Polygons should be closed, and directed clockwise. If you're not sure if that is the case,</span>
        <span class="comment">// call the correct algorithm</span>
        <span class="comment">//geometry::correct(poly);</span>

        <span class="comment">// Polygons can be streamed as Well Known Text (OGC WKT)</span>
        std::cout &lt;&lt; poly &lt;&lt; std::endl;

        <span class="comment">// As with lines, bounding box of polygons can be calculated</span>
        <a name="_a3"></a><a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;geometry::point_xy&lt;double&gt;</a> &gt; b;
        <a name="a4"></a><a class="code" href="group__envelope.html#g2970ab50558bce38e941f06741816cdc" title="Calculate envelope of a point.">geometry::envelope</a>(poly, b);
        std::cout &lt;&lt; b.<a name="a5"></a><a class="code" href="classgeometry_1_1box.html#69ed9036d49dd279575a93a07228070a">min_corner</a>() &lt;&lt; <span class="stringliteral">"-"</span> &lt;&lt; b.<a name="a6"></a><a class="code" href="classgeometry_1_1box.html#b0c7fd4cdd0b350ff3ecabca5e3c491c">max_corner</a>() &lt;&lt; std::endl;


        <span class="comment">// The area of the polygon can be calulated</span>
        std::cout &lt;&lt; <span class="stringliteral">"area: "</span> &lt;&lt; <a name="a7"></a><a class="code" href="group__area.html#g9bab871ad28276d6778b5c1e35082364" title="Calculate area of box.">geometry::area</a>(poly) &lt;&lt; std::endl;

        <span class="comment">// And the centroid, which is the center of gravity</span>
        P <a name="a8"></a><a class="code" href="group__centroid.html#g3fd3cba1fc74c22b0f3be5adc96ec426" title="Calculate centroid of polygon.">centroid</a>;
        <a name="a9"></a><a class="code" href="namespacegeometry.html#f78f711d18dd17c0c1fff73e5501cd92">geometry::centroid</a>(poly, centroid);
        std::cout &lt;&lt; <span class="stringliteral">"centroid: "</span> &lt;&lt; centroid &lt;&lt; std::endl;

        <span class="comment">// Actually in most cases you don't want the centroid, which is only defined for polygons.</span>
        <span class="comment">// You want a nice labelpoint instead. Call labelpoint in those cases, which is defined</span>
        <span class="comment">// for all geometries</span>
        <span class="comment">/* not yet in preview, syntax might change</span>
<span class="comment">        std::cout &lt;&lt; "labelpoints: ";</span>
<span class="comment">        geometry::label_info&lt;0&gt;(poly, , std::ostream_iterator&lt;P&gt;(std::cout, " "));</span>
<span class="comment">        std::cout &lt;&lt; std::endl;</span>
<span class="comment">        */</span>

        <span class="comment">// The number of points have to called per ring separately</span>
        std::cout &lt;&lt; <span class="stringliteral">"number of points in outer ring: "</span> &lt;&lt; poly.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().size() &lt;&lt; std::endl;

        <span class="comment">// Polygons can have one or more inner rings, also called holes, donuts, islands, interior rings.</span>
        <span class="comment">// Let's add one</span>
        {
                poly.<a name="a10"></a><a class="code" href="classgeometry_1_1polygon.html#14502b48db19e3e4becc27cbadf4b980">inners</a>().resize(1);
                <a name="_a11"></a><a class="code" href="classgeometry_1_1linear__ring.html" title="A linear_ring (linear linear_ring) is a closed line which should not be selfintersecting...">geometry::linear_ring&lt;P&gt;</a>&amp; inner = poly.<a class="code" href="classgeometry_1_1polygon.html#14502b48db19e3e4becc27cbadf4b980">inners</a>().back();

                <span class="keyword">const</span> <span class="keywordtype">double</span> coor[][2] = { {4.0, 2.0}, {4.2, 1.4}, {4.8, 1.9}, {4.4, 2.2}, {4.0, 2.0} };
                <span class="keywordtype">int</span> n = <span class="keyword">sizeof</span>(coor) / <span class="keyword">sizeof</span>(coor[0]);

                inner.reserve(n);
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
                {
                        inner.push_back(P(coor[i][0], coor[i][1]));
                }
        }

        <a name="a12"></a><a class="code" href="namespacegeometry.html#16933c374b4088c63a2f9b9b48e0fc08">geometry::correct</a>(poly);

        std::cout &lt;&lt; <span class="stringliteral">"with inner ring:"</span> &lt;&lt; poly &lt;&lt; std::endl;
        <span class="comment">// The area of the polygon is changed of course</span>
        std::cout &lt;&lt; <span class="stringliteral">"new area of polygon: "</span> &lt;&lt; <a class="code" href="group__area.html#g9bab871ad28276d6778b5c1e35082364" title="Calculate area of box.">geometry::area</a>(poly) &lt;&lt; std::endl;
        <a class="code" href="namespacegeometry.html#f78f711d18dd17c0c1fff73e5501cd92">geometry::centroid</a>(poly, centroid);
        std::cout &lt;&lt; <span class="stringliteral">"new centroid: "</span> &lt;&lt; centroid &lt;&lt; std::endl;

        <span class="comment">// You can test whether points are within a polygon</span>
        std::cout &lt;&lt; <span class="stringliteral">"point in polygon:"</span>
                &lt;&lt; <span class="stringliteral">" p1: "</span>  &lt;&lt; boolstr(<a name="a13"></a><a class="code" href="namespacegeometry.html#f426c4df13cec91744da6f6ca400bf17">geometry::within</a>(P(3.0, 2.0), poly))
                &lt;&lt; <span class="stringliteral">" p2: "</span>  &lt;&lt; boolstr(<a class="code" href="namespacegeometry.html#f426c4df13cec91744da6f6ca400bf17">geometry::within</a>(P(3.7, 2.0), poly))
                &lt;&lt; <span class="stringliteral">" p3: "</span>  &lt;&lt; boolstr(<a class="code" href="namespacegeometry.html#f426c4df13cec91744da6f6ca400bf17">geometry::within</a>(P(4.4, 2.0), poly))
                &lt;&lt; std::endl;

        <span class="comment">// You can call for_each or for_each_segment on polygons to, this will visit all points / segments</span>
        <span class="comment">// in outer ring and inner rings</span>
        <span class="comment">//geometry::for_each(poly, f);</span>

        <span class="comment">// As with linestrings and points, you can derive from polygon to add, for example,</span>
        <span class="comment">// fill color and stroke color. Or SRID (spatial reference ID). Or Z-value. Or a property map.</span>
        <span class="comment">// We don't show this here.</span>

        <span class="comment">// You can clip the polygon using a bounding box</span>
        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
        <span class="keyword">typedef</span> std::vector&lt;geometry::polygon&lt;P&gt; &gt; PV;
        PV v;

        <a name="a14"></a><a class="code" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a>(cb, poly, std::back_inserter(v));
        std::cout &lt;&lt; <span class="stringliteral">"Clipped output polygons"</span> &lt;&lt; std::endl;
        <span class="keywordflow">for</span> (PV::const_iterator it = v.begin(); it != v.end(); it++)
        {
                std::cout &lt;&lt; *it &lt;&lt; std::endl;
        }


        <span class="comment">// If you really want:</span>
        <span class="comment">//   You don't have to use a vector, you can define a polygon with a deque or list</span>
        <span class="comment">//   You can specify the container for the points and for the inner rings independantly</span>

        <a class="code" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">geometry::polygon&lt;P, std::vector, std::list&gt;</a> poly2;
        poly2.<a name="a15"></a><a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(2.8, 1.9));
        poly2.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(2.9, 2.4));
        poly2.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(3.3, 2.2));
        poly2.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(3.2, 1.8));
        poly2.<a class="code" href="classgeometry_1_1polygon.html#786560a786d1cfadd1036e7d456a1fd4">outer</a>().push_back(P(2.8, 1.9));

        <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 14, 2008</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2008 Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands<br>
Copyright © 2008 Bruno Lalande, Paris, France</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
