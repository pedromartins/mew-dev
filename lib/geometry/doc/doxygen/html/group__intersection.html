<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277"></td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.7 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>intersection: intersection algorithms</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename PB , typename POLY , typename O_IT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O_IT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersection.html#gf1c1081ad202414de0877c1445ba6ef9">geometry::intersection</a> (const box&lt; PB &gt; &amp;cb, const POLY &amp;poly, O_IT out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clips a <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> with a <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>.  <a href="#gf1c1081ad202414de0877c1445ba6ef9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename PB , typename IT , typename O_IT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O_IT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967">geometry::intersection</a> (const box&lt; PB &gt; &amp;b, IT begin, IT end, O_IT out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clips a sequence of points (e.g. vector or <a class="el" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a>) with a <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>.  <a href="#g36d0bbb2f06e3ee7116a3df7f7e0e967"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename P , typename S1 , typename S2 , typename O_IT &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">intersection_result&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__intersection.html#gb2e83dccd8953a6334a9555e0d61346a">geometry::intersection_segment</a> (const S1 &amp;s1, const S2 &amp;s2, O_IT out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate zero, one or two intersections of two linesegments, using Cramer's rule.  <a href="#gb2e83dccd8953a6334a9555e0d61346a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The intersection algorithm intersects two geometries, resulting in a third <a class="el" href="namespacegeometry.html">geometry</a>. Intersection can be implemented for OGC geometries. Besides that an often used intersection is the intersection of a linestring or a polygon with a box. This is normally called a clip. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gf1c1081ad202414de0877c1445ba6ef9"></a><!-- doxytag: member="geometry::intersection" ref="gf1c1081ad202414de0877c1445ba6ef9" args="(const box&lt; PB &gt; &amp;cb, const POLY &amp;poly, O_IT out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PB , typename POLY , typename O_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O_IT geometry::intersection           </td>
          <td>(</td>
          <td class="paramtype">const box&lt; PB &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const POLY &amp;&nbsp;</td>
          <td class="paramname"> <em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O_IT&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clips a <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> with a <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>. 
<p>
A <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> is intersected (clipped) by the specified <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>. Note that clipping one <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> can result in zero or more polygons. The resulting polygons, are sent to the specified output operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the clipping <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poly</em>&nbsp;</td><td>the <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> to be clipped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>the output iterator, outputting polygons </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the output iterator </dd></dl>
<dl class="user" compact><dt><b>Template parameters:</b></dt><dd><ul>
<li><em>PB</em> <a class="el" href="classgeometry_1_1point.html" title="Basic point class, having coordinates dfined in a neutral way.">point</a> type of <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a></li><li><em>POLY</em> <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> type</li><li><em>O_IT</em> output iterator </li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default clipping <a class="el" href="namespacegeometry_1_1strategy.html">strategy</a>, Liang-Barsky, is used. The algorithm is currently only implemented for 2D xy points. It could be generic for most ll cases, but not across the 180 meridian so that issue is still on the todo-list. </dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing clipping of <a class="el" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a> with <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>  <div class="fragment"><pre class="fragment">{
        <span class="keyword">typedef</span> <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;
        <span class="keyword">typedef</span> std::vector&lt;geometry::polygon&lt;P&gt; &gt; PV;

        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
        <a class="code" href="classgeometry_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">geometry::polygon&lt;P&gt;</a> poly;
        geometry::from_wkt(<span class="stringliteral">"POLYGON((2 1.3,2.4 1.7,2.8 1.8,3.4 1.2,3.7 1.6,3.4 2,4.1 3,5.3 2.6,5.4 1.2,4.9 0.8,2.9 0.7,2 1.3)"</span>
                        <span class="stringliteral">",(4 2,4.2 1.4,4.8 1.9,4.4 2.2,4 2))"</span>, poly);

        PV v;
        <a class="code" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a>(cb, poly, std::back_inserter(v));

        std::cout &lt;&lt; <span class="stringliteral">"Clipped polygon(s) "</span> &lt;&lt; std::endl;
        <span class="keywordflow">for</span> (PV::const_iterator it = v.begin(); it != v.end(); it++)
        {
                std::cout &lt;&lt; *it &lt;&lt; std::endl;
        }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g36d0bbb2f06e3ee7116a3df7f7e0e967"></a><!-- doxytag: member="geometry::intersection" ref="g36d0bbb2f06e3ee7116a3df7f7e0e967" args="(const box&lt; PB &gt; &amp;b, IT begin, IT end, O_IT out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PB , typename IT , typename O_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">O_IT geometry::intersection           </td>
          <td>(</td>
          <td class="paramtype">const box&lt; PB &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O_IT&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clips a sequence of points (e.g. vector or <a class="el" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a>) with a <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>. 
<p>
A sequence of points is intersected (clipped) by the specified <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a> and the resulting <a class="el" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a>, or pieces of linestrings, are sent to the specified output operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>the clipping <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>begin iterator of sequence to be clipped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>end iterator of sequence to be clipped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>the output iterator, outputting linestrings </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the output iterator </dd></dl>
<dl class="user" compact><dt><b>Template parameters:</b></dt><dd><ul>
<li><em>PB</em> <a class="el" href="classgeometry_1_1point.html" title="Basic point class, having coordinates dfined in a neutral way.">point</a> type of <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a></li><li><em>IT</em> input iterator</li><li><em>O_IT</em> output iterator </li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default clipping <a class="el" href="namespacegeometry_1_1strategy.html">strategy</a>, Liang-Barsky, is used. The algorithm is currently only implemented for 2D xy points. It could be generic for most ll cases, but not across the 180 meridian so that issue is still on the todo-list. </dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing clipping of <a class="el" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a> with <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>  <div class="fragment"><pre class="fragment">{
        <span class="keyword">typedef</span> <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;
        <a class="code" href="classgeometry_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">geometry::linestring&lt;P&gt;</a> line;
        geometry::from_wkt(<span class="stringliteral">"linestring(1.1 1.1, 2.5 2.1, 3.1 3.1, 4.9 1.1, 3.1 1.9)"</span>, line);
        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
        std::cout &lt;&lt; <span class="stringliteral">"Clipped linestring(s) "</span> &lt;&lt; std::endl;
        <a class="code" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a>(cb, line.begin(), line.end(),
                        std::ostream_iterator&lt;geometry::linestring&lt;P&gt; &gt;(std::cout, <span class="stringliteral">"\n"</span>));
}
</pre></div> Example showing clipping of vector, outputting vectors, with <a class="el" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">box</a>  <div class="fragment"><pre class="fragment">{
        <span class="keyword">typedef</span> <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;
        std::vector&lt;P&gt; vector_in;
        geometry::from_wkt&lt;P&gt;(<span class="stringliteral">"linestring(1.1 1.1, 2.5 2.1, 3.1 3.1, 4.9 1.1, 3.1 1.9)"</span>,
                                        std::back_inserter(vector_in));

        <a class="code" href="classgeometry_1_1box.html" title="Class box: defines a box made of two describing points.">geometry::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
        <span class="keyword">typedef</span> std::vector&lt;std::vector&lt;P&gt; &gt; VV;
        VV vector_out;
        <a class="code" href="group__intersection.html#g36d0bbb2f06e3ee7116a3df7f7e0e967" title="Clips a sequence of points (e.g. vector or linestring) with a box.">geometry::intersection</a>(cb, vector_in.begin(), vector_in.end(),
                                        std::back_inserter(vector_out));

        std::cout &lt;&lt; <span class="stringliteral">"Clipped vector(s) "</span> &lt;&lt; std::endl;
        <span class="keywordflow">for</span> (VV::const_iterator it = vector_out.begin(); it != vector_out.end(); it++)
        {
                std::copy(it-&gt;begin(), it-&gt;end(), std::ostream_iterator&lt;P&gt;(std::cout, <span class="stringliteral">" "</span>));
                std::cout &lt;&lt; std::endl;
        }
</pre></div> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="3__linestring__example_8cpp-example.html#a9">3_linestring_example.cpp</a>, and <a class="el" href="4__polygon__example_8cpp-example.html#a14">4_polygon_example.cpp</a>.</dl>
</div>
</div><p>
<a class="anchor" name="gb2e83dccd8953a6334a9555e0d61346a"></a><!-- doxytag: member="geometry::intersection_segment" ref="gb2e83dccd8953a6334a9555e0d61346a" args="(const S1 &amp;s1, const S2 &amp;s2, O_IT out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename S1 , typename S2 , typename O_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">intersection_result geometry::intersection_segment           </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O_IT&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate zero, one or two intersections of two linesegments, using Cramer's rule. 
<p>
Two intersections are returned if segments are on same line and (partially) overlap. One intersection is returned if segments intersect Intersection points is vector of points, might be yet another pointtype then points making up <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>first <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>second <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>output iterator </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the intersection result, a struct containing the intersection type, and two calculated values which can be examined further if necessary </dd></dl>
<dl class="user" compact><dt><b>Template parameters:</b></dt><dd><ul>
<li><em>P</em> type of outputted intersection point(s). Must be specified, cannot be deducted from parameters. Type might be different from <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> points.</li><li><em>S1</em> first <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> type</li><li><em>S2</em> second <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> type</li><li><em>O_IT</em> output iterator </li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><b>The algorithm is currently only implemented for 2D Cartesian points. It will be redesigned to work with strategies.</b> Algorithms to calculate <a class="el" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">segment</a> intersections on a sphere are available, see <a href="http://williams.best.vwh.net/avform.htm.">http://williams.best.vwh.net/avform.htm.</a> </dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing intersection of two segments  <div class="fragment"><pre class="fragment">{
        <span class="keyword">typedef</span> <a class="code" href="classgeometry_1_1point__xy.html" title="2D point in Cartesian coordinate system">geometry::point_xy&lt;double&gt;</a> P;
        P a(0, 2);
        P b(4, 2);
        P c(3, 0);
        P d(3, 4);
        <a class="code" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">geometry::segment&lt;P&gt;</a> s1(a, b);
        <a class="code" href="structgeometry_1_1segment.html" title="Class segment: small containing two (templatized) point references.">geometry::segment&lt;P&gt;</a> s2(c, d);

        std::cout &lt;&lt; <span class="stringliteral">"Intersection point(s): "</span>;
        <a class="code" href="structgeometry_1_1intersection__result.html" title="Encapsulates the result of a segment intersection.">geometry::intersection_result</a> r = geometry::intersection_segment&lt;P&gt;(s1, s2,
                std::ostream_iterator&lt;P&gt;(std::cout, <span class="stringliteral">"\n"</span>));
        std::cout &lt;&lt; <span class="stringliteral">"Intersection result: "</span> &lt;&lt; r.is_type &lt;&lt; std::endl;
}
</pre></div> </dd></dl>

</div>
</div><p>
</div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 14, 2008</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2008 Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands<br>
Copyright © 2008 Bruno Lalande, Paris, France</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
