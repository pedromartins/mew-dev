<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top"><img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277"></td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.7 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="points">Point concepts, point types, strategies, and algorithms </a></h1>This page explains the design of the library with respect to the generic point, derived point types, and strategies and algorithms. Note that, for clarity, the listings do not list the complete classes. <br>
<br>
 <h2><a class="anchor" name="point">
class point</a></h2>
The provided point base class is templatized by coordinate-type and dimension. It is generic and coordinate access is implemented in a neutral way, using <b>get</b> methods (as also done in boost::tuple classes). Note that all algorithms work on <a class="el" href="structgeometry_1_1_point.html">point concepts</a>. The point type below fulfils to these concepts, but all algorithms take any point matching the concepts.<p>
 <div class="fragment"><pre class="fragment"></pre></div> There are two member function templates to get and set values: <div class="fragment"><pre class="fragment"></pre></div> The coordinates themselves are stored using an array <div class="fragment"><pre class="fragment"></pre></div><p>
<br>
 <h2><a class="anchor" name="point_point_xy">
class point_xy for Cartesian 2D points</a></h2>
Library users will normally work with derived point types, or with user defined point types. The point_xy point is derived from the generic point and exposes its coordinates as x- and y-values. <div class="fragment"><pre class="fragment"></pre></div><p>
<br>
 <h2><a class="anchor" name="xystrategy">
Strategy for point_xy for distance calculation</a></h2>
<br>
 For each point type, there might be strategies for primitive operations. Take, for example, the distance algorithm. There is a strategy for points (usually with x,y) implementing distance calculations (which resides in namespace strategy::distance):  <div class="fragment"><pre class="fragment">                        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2 = P1&gt;
                        <span class="keyword">struct </span>pythagoras
                        {
                                BOOST_CONCEPT_REQUIRES(((ConstPoint&lt;P1&gt;)) ((ConstPoint&lt;P2&gt;)),
                                (distance_result)) operator()(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2)<span class="keyword"> const</span>
<span class="keyword">                                </span>{
                                        <span class="comment">// Calculate distance using Pythagoras</span>
                                }
                        };
</pre></div> Note that the algorithm validates if the arguments satisfy the ConstPoint concept, using a boost BCCL construct. The algorithm returns a distance_result struct, which is usually the squared result, having an operator to take the square root if necessary.<p>
Note also that although the algorithm is target to points within Cartesian coordinate systems (usually x,y), it works on generic points implementing get&lt;&gt; access. It works for any point having one, two, three, or more dimensions.<p>
<br>
 <h2><a class="anchor" name="strategy">
class strategy_traits</a></h2>
<br>
 The <b>strategy_traits</b> class matches <b>point-types</b> with <b>strategies</b>. <br>
 For each point-type there is a specialization which defines which strategy should be used. <em>(Detail: because the library can calculate the distance of two different types, the strategy_traits classes use actually two types).</em> The following specialization defines that for point_xy points, the Pythagoras strategy should be used.  <div class="fragment"><pre class="fragment">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
        <span class="keyword">struct </span>strategy_traits&lt;point_xy&lt;T1&gt;, point_xy&lt;T2&gt; &gt;
        {
                <span class="keyword">typedef</span> strategy::distance::pythagoras&lt;point_xy&lt;T1&gt;, point_xy&lt;T2&gt; &gt; point_distance;
        };
</pre></div> If library users define their own point types, and still want to use the provided Pythagoras strategy for distance calculations, they should declare the strategy_traits class (in the namespace <a class="el" href="namespacegeometry.html">geometry</a>) to match their point type to the Pythagoras strategy. An example is given in "custom point example"<p>
<br>
 <h2><a class="anchor" name="point_point_ll">
class point_ll for points having latitude and longitude</a></h2>
Besides xy point types there are also point types using polar coordinates. The library provides a predefined point class using latitude and longitude, often referred to as latlong or lola. This class, <b>point_ll</b>. does not define x/y, but defines lat/lon methods instead.  <div class="fragment"><pre class="fragment">        <span class="keyword">template</span> &lt;dr_selector D, <span class="keyword">typename</span> T = <span class="keywordtype">double</span>&gt;
        <span class="keyword">class </span>point_ll : <span class="keyword">public</span> point&lt;T, 2&gt;
        {
                        <span class="keyword">inline</span> <span class="keyword">const</span> T&amp; lon() const
                        <span class="keyword">inline</span> <span class="keyword">const</span> T&amp; lat() const
                        <span class="keyword">inline</span> <span class="keywordtype">void</span> lon(<span class="keyword">const</span> T&amp; v)
                        <span class="keyword">inline</span> <span class="keywordtype">void</span> lat(<span class="keyword">const</span> T&amp; v)
        };
</pre></div> For these point types with polar coordinates, of course, other strategies are implemented. For distance calculation there are three different strategies provided:<ul>
<li><b>haversine:</b> fast, simple and often used, but not so accurate for calculations on the Earth</li><li><b>Andoyer:</b> not well-known but fast and accurate</li><li><b>Vincenty:</b> well-known, slower but very accurate.</li></ul>
<p>
The strategy_traits class defines only one to be the default distance calculation strategy.  <div class="fragment"><pre class="fragment">        <span class="keyword">template</span> &lt;dr_selector D1, <span class="keyword">typename</span> T1, dr_selector D2, <span class="keyword">typename</span> T2&gt;
        <span class="keyword">struct </span>strategy_traits&lt;point_ll&lt;D1, T1&gt;, point_ll&lt;D2, T2&gt; &gt;
        {
                <span class="keyword">typedef</span> strategy::distance::haversine&lt;point_ll&lt;D1, T1&gt;, point_ll&lt;D2,T2&gt; &gt; point_distance;
        };
</pre></div><p>
<br>
 <h2><a class="anchor" name="distance">
The distance algorithm</a></h2>
Finally, the distance algorithm automatically selects the right strategy using the strategy_traits class:  <div class="fragment"><pre class="fragment">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> P1, <span class="keyword">typename</span> P2&gt;
        <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="group__distance.html#g8998816466251f035b5ab6c3f76f2ec0" title="Calculate distance between two points.">distance</a>(<span class="keyword">const</span> P1&amp; p1, <span class="keyword">const</span> P2&amp; p2)
        {
</pre></div> It then calls the (overloaded) method where a strategy can specified explicitly <div class="fragment"><pre class="fragment">                <span class="keywordflow">return</span> <a class="code" href="group__distance.html#g8998816466251f035b5ab6c3f76f2ec0" title="Calculate distance between two points.">distance</a>(p1, p2, <span class="keyword">typename</span> strategy_traits&lt;P1, P2&gt;::point_distance());
        }
</pre></div><p>
Alternatively, the library user can call this overloaded method directly:<ul>
<li>to specify another (for example more accurate) strategy</li><li>to specify a value (e.g. Earth radius) in the constructor of the strategy</li><li>because there is no default strategy implemented for the specified point type or point type combination</li></ul>
<p>
<br>
 <h2><a class="anchor" name="other">
Other algorithms</a></h2>
The explanation above concentrates on distance algorithms. However, the design is used for other algorithms as well: within, centroid, area, distance to a line segment, etc.<p>
<br>
 <h2><a class="anchor" name="other_geometries">
Other geometries</a></h2>
All other <a class="el" href="namespacegeometry.html">geometry</a> classes in the Geometry Library are class templates and the point type (a user defined point type, or point_xy or point_ll) can be specified as a template argument.<p>
<br>
 <h2><a class="anchor" name="Summary">
Summary</a></h2>
<ul>
<li>all algorithms work on a point concept</li><li>library users might use their own point types</li><li>there are some predefined point types provided</li><li>for each point type (or point-type-combination) strategies may be defined or combined</li><li>the strategy_traits class selects the default strategy</li><li>the algorithms use the default strategy</li><li>the library user can select another strategy </li></ul>
</div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 14, 2008</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2008 Barend Gehrels, Geodan Holding B.V. Amsterdam, the Netherlands<br>
Copyright © 2008 Bruno Lalande, Paris, France</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
