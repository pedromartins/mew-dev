#summary Hardware Team subwiki

A few initial ideas to get the ball rolling -- Harry

*Main working areas:*
||<wiki:toc max_depth="1" />||

----

=i have decreed that it is arduino, no one contributed early enough!=

~~= MCU platform =~~


~~For choice of microcontroller platform we have PIC, Arduino (atmega), ARM or parallax stamp (probably others). ~~
~~Things to consider when deciding which to use - ~~
 * ~~Do the chips suit the application in terms of pin count, hardware peripherals (i2c, PWM, counters, timers, A/D...), processing power, package?~~
 * ~~What are the available resources? - Online communities, programming equipment(we might be able to use university programmers), libraries, documentation, etc~~
 * ~~What experience does the group have with this platform?~~
 * ~~What costs are associated with it in terms of money, time, space on the bot, etc.~~

~~Also we need to think about our approach towards the low level processing that is required. Are going to go for a modular approach? - separate MCUs for the servo controller, stepper/DC motors and sensors might make sense since we can easily fit plenty of slaves on the i2c bus.~~

= Sensors =

The bot is going to need to measure distance so rangefinders will be useful. The most common output method for these sensors is an analogue voltage, but some use PWM or even i2c. If we use analogue voltages, we will have to consider low-pass filters to clean the signal if they aren't already implemented in the sensors.
An electronic compass could be useful for orientation purposes (maybe even gyros and accelerometers...)
Our wiki page on sensors is [http://code.google.com/p/mew-dev/wiki/Sensors here].

= Actuators = 

Until the mechanical team have come to a decision, we should think about which actuators we would like them to use. For driving the wheels of the bot, DC motors, stepper motors, modified servos and AC motors are possibilities. What electronic requirements would each of these need?
For the grippers and other effectors on the bot, we will be using servos and possibly a linear actuator. 

== drive motors ==
The motor controllers are these:
http://www.technobots.co.uk/Data%20Sheets/1502-001.pdf

They will be powerful enough to power the motors provided we don't stall them - we need software protection to power them off if the optical encoders detect stalling.


I suggest 1 arduino to read the encoders and output to the motors - then you get a good feedback loop.  Here's some quick sudocode:
{{{
define ACCEL_CONST 20       // aprox 200ms to get to speed or to stop.
while (1) {
  ds=read_desired_speed();  // from PC, probably into an I2C memory location
  as=actual_speed;          // set by encoder in a timed interrupt routine
  deltaSum+=ds-as;          // speed delta.  Additive so that average speed=desired speed.
  if ((delatSum>STALL_THRESHOLD) || (delatSum< -STALL_THRESHOLD)) {
    // motor is stalled
    output_i2c(MOTOR_BASE_ADDRESS,0);
    sleep(5000);            // wait 5 secs, then retry.
    deltaSum=0;
  }
  // set motor speed
  output_i2c(MOTOR_BASE_ADDRESS,deltaSum / ACCEL_CONST);
  // sleep to allow motor speed to change, prevents too much
  // negative feedback causing oscillations.
  sleep(10);
}

void ISR() {  //called on a fast timer, although could be integrated into above loop
  int a = read_encoder_state();  // returns 0, 1, 2, or 3.
  static int last_state = 0;
  
  // decay speed, this acts as a simple filter.
  actual_speed=actual_speed - actual_speed>>2;
  actual_speed+=difference(a, last_state);  // where difference retuns +1, 0, or -1;
  last_state=a;

}
}}}
(note in the above code, yes, there is a race, but it won't matter since 1 error in actual_speed won't cause a noticeable problem)

There are more efficient hardware ways of handling an encoder than using timer interrupts. We should probably look at using an external clock source for incrementing a timer. Then speed calculation requires no interrupt. speed = k`*`(current_pulses_counted - previous pulses_counted)/delta_time. There is more information in the Counter chapters of the atmega 168 datasheet - [http://www.atmel.com/dyn/resources/prod_documents/doc2545.pdf here]. -- Harry

Interesting article on creating a PIC based DC motor controller with PID control - [http://www.seattlerobotics.org/encoder/200205/pidmc.html here].